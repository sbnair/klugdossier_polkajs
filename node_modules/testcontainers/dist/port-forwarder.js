"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PortForwarderInstance = exports.PortForwarder = void 0;
const ssh_remote_port_forward_1 = require("ssh-remote-port-forward");
const logger_1 = require("./logger");
const generic_container_1 = require("./generic-container");
const uuid_1 = require("./uuid");
class PortForwarder {
    constructor(sshConnection, container) {
        this.sshConnection = sshConnection;
        this.container = container;
    }
    exposeHostPort(port) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.info(`Exposing host port ${port}`);
            yield this.sshConnection.remoteForward("localhost", port);
        });
    }
    getNetworkId() {
        return this.container.getNetworkId(this.getNetworkName());
    }
    getIpAddress() {
        return this.container.getIpAddress(this.getNetworkName());
    }
    getNetworkName() {
        return this.container.getNetworkNames()[0];
    }
}
exports.PortForwarder = PortForwarder;
class PortForwarderInstance {
    static isRunning() {
        return this.instance !== undefined;
    }
    static getImageName() {
        if (process.env.SSHD_CONTAINER_IMAGE !== undefined) {
            this.IMAGE_NAME = process.env.SSHD_CONTAINER_IMAGE.split(/:/)[0];
        }
        return this.IMAGE_NAME;
    }
    static getImageVersion() {
        if (process.env.SSHD_CONTAINER_IMAGE !== undefined) {
            this.IMAGE_VERSION = process.env.SSHD_CONTAINER_IMAGE.split(/:/)[1];
        }
        return this.IMAGE_VERSION;
    }
    static getInstance(dockerClient) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.instance) {
                this.instance = this.createInstance(dockerClient);
            }
            return this.instance;
        });
    }
    static createInstance(dockerClient) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.debug(`Creating new Port Forwarder`);
            const username = "root";
            const password = new uuid_1.RandomUuid().nextUuid();
            const container = yield new generic_container_1.GenericContainer(this.getImageName(), this.getImageVersion())
                .withName(`testcontainers-port-forwarder-${dockerClient.getSessionId()}`)
                .withDaemonMode()
                .withExposedPorts(22)
                .withEnv("PASSWORD", password)
                .withCmd([
                "sh",
                "-c",
                `echo "${username}:$PASSWORD" | chpasswd && /usr/sbin/sshd -D -o PermitRootLogin=yes -o AddressFamily=inet -o GatewayPorts=yes`,
            ])
                .start();
            const host = dockerClient.getHost();
            const port = container.getMappedPort(22);
            logger_1.log.debug(`Connecting to Port Forwarder on ${host}:${port}`);
            const connection = yield ssh_remote_port_forward_1.createSshConnection({ host, port, username, password });
            connection.unref();
            return new PortForwarder(connection, container);
        });
    }
}
exports.PortForwarderInstance = PortForwarderInstance;
PortForwarderInstance.IMAGE_NAME = "testcontainers/sshd";
PortForwarderInstance.IMAGE_VERSION = "1.0.0";
